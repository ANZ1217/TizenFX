// Copyright (c) 2017 Samsung Electronics Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// This File has been auto-generated by SWIG and then modified using DALi Ruby Scripts
// Some have been manually changed

namespace Tizen.NUI
{

    using System;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Animation can be used to animate the properties of any number of objects, typically Actors.
    /// If the "Finished" event is connected to a member function of an object, it must be disconnected before the object is destroyed.
    /// This is typically done in the object destructor, and requires either the Animation handle to be stored.
    /// The overall animation time is superseded by the values given in the Duration property used when calling the AnimateTo(), AnimateBy(), AnimateBetween() and AnimatePath() methods.
    /// If any of the individual calls to those functions exceeds the overall animation time(Duration), then the overall animation time is automatically extended.
    /// </summary>
    public class Animation : BaseHandle
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;

        internal Animation(global::System.IntPtr cPtr, bool cMemoryOwn) : base(NDalicPINVOKE.Animation_SWIGUpcast(cPtr), cMemoryOwn)
        {
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Animation obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Animation()
        {
            DisposeQueue.Instance.Add(this);
        }

        /// <summary>
        /// To make Animation instance be disposed.
        /// </summary>
        public override void Dispose()
        {
            if (!Stage.IsInstalled())
            {
                DisposeQueue.Instance.Add(this);
                return;
            }

            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        NDalicPINVOKE.delete_Animation(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
                global::System.GC.SuppressFinalize(this);
                base.Dispose();
            }
        }

        /// <summary>
        /// Create an initialized Animation.
        /// The animation will not loop.
        /// The default end action is "Cancel".
        /// The default Alpha function is linear.
        /// Precodition : DurationmSeconds must be greater than zero.
        /// </summary>
        /// <param name="durationMilliSeconds">The duration in milli seconds (int).</param>
        public Animation(int durationMilliSeconds) : this(NDalicPINVOKE.Animation_New((float)durationMilliSeconds / 1000.0f), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        private AnimationFinishedEventCallbackType _animationFinishedEventCallback;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void AnimationFinishedEventCallbackType(IntPtr data);
        private event EventHandler _animationFinishedEventHandler;
        /**
        * @brief Event for Finished signal which can be used to subscribe/unsubscribe the event handler
        * Finished signal is emitted when an Animation's animations have finished.
        */
        public event EventHandler Finished
        {
            add
            {
                if (_animationFinishedEventHandler == null)
                {
                    _animationFinishedEventCallback = OnFinished;
                    FinishedSignal().Connect(_animationFinishedEventCallback);
                }

                _animationFinishedEventHandler += value;
            }
            remove
            {
                _animationFinishedEventHandler -= value;

                if (_animationFinishedEventHandler == null && _animationFinishedEventCallback != null)
                {
                    FinishedSignal().Disconnect(_animationFinishedEventCallback);
                }
            }
        }
        private void OnFinished(IntPtr data)
        {
            if (_animationFinishedEventHandler != null)
            {
                //here we send all data to user event handlers
                _animationFinishedEventHandler(this, null);
            }
        }


        internal static Animation GetAnimationFromPtr(global::System.IntPtr cPtr)
        {
            Animation ret = new Animation(cPtr, false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        private float MilliSecondsToSeconds(int millisec)
        {
            return (float)millisec / 1000.0f;
        }

        private int SecondsToMilliSeconds(float sec)
        {
            return (int)(sec * 1000);
        }


        /// <summary>
        /// Gets/Sets the duration of animation
        /// </summary>
        public int Duration
        {
            set
            {
                SetDuration(MilliSecondsToSeconds(value));
            }
            get
            {
                return SecondsToMilliSeconds(GetDuration());
            }
        }

        /// <summary>
        ///  Gets/Sets the default alpha function for an animation.
        /// </summary>
        public AlphaFunction DefaultAlphaFunction
        {
            set
            {
                SetDefaultAlphaFunction(value);
            }
            get
            {
                AlphaFunction ret = GetDefaultAlphaFunction();
                return ret;
            }
        }

        /// <summary>
        /// Queries the state of the animation.
        /// </summary>
        public States State
        {
            get
            {
                return GetState();
            }
        }

        /// <summary>
        /// Set : Enables looping for 'count' repeats. A zero is the same as Looping = true; i.e.repeat forever.
        /// If Play() Stop() or 'count' loops is reached, the loop counter will reset.
        /// Setting this parameter does not cause the animation to Play().
        /// 
        /// Get : Gets the loop count. A zero is the same as Looping = true; ie repeat forever. 
        /// The loop count is initially 1 for play once.
        /// </summary>
        public int LoopCount
        {
            set
            {
                SetLoopCount(value);
            }
            get
            {
                int ret = GetLoopCount();
                return ret;
            }
        }

        /// <summary>
        /// Gets/Sets the status of whether the animation will loop.
        /// This property resets the loop count and should not be used with LoopCount property.
        /// Setting this parameter does not cause the animation to Play().
        /// </summary>
        public bool Looping
        {
            set
            {
                SetLooping(value);
            }
            get
            {
                bool ret = IsLooping();
                return ret;
            }
        }


        /// <summary>
        /// Gets/Sets the end action of the animation.
        /// This action is performed when the animation ends or if it is stopped.
        /// Default end action is Cancel
        /// </summary>
        public EndActions EndAction
        {
            set
            {
                SetEndAction(value);
            }
            get
            {
                return GetEndAction();
            }
        }


        /// <summary>
        /// Stops the animation.
        /// </summary>
        /// <param name="action">end action can be set</param>
        public void Stop(EndActions action = EndActions.Cancel)
        {
            SetEndAction(action);
            NDalicPINVOKE.Animation_Stop(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Gets the current loop count.
        /// A value 0 to CurrentLoop indicating the current loop count when looping.
        /// </summary>
        public int CurrentLoop
        {
            get
            {
                return GetCurrentLoop();
            }
        }

        /// <summary>
        /// Gets/Sets the disconnect action.
        /// If any of the animated property owners are disconnected from the stage while the animation is being played, then this action is performed.
        /// Default action is to Cancel.
        /// </summary>
        public EndActions DisconnectAction
        {
            set
            {
                NDalicPINVOKE.Animation_SetDisconnectAction(swigCPtr, (int)value);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            }
            get
            {
                Animation.EndActions ret = (Animation.EndActions)NDalicPINVOKE.Animation_GetDisconnectAction(swigCPtr);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
                return ret;
            }
        }


        /// <summary>
        /// Gets/Sets the progress of the animation.
        /// The animation will play(or continue playing) from this point.
        /// The progress must be in the 0-1 interval or in the play range interval if defined
        /// otherwise, it will be ignored.
        /// </summary>
        public float CurrentProgress
        {
            set
            {
                NDalicPINVOKE.Animation_SetCurrentProgress(swigCPtr, value);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            }
            get
            {
                float ret = NDalicPINVOKE.Animation_GetCurrentProgress(swigCPtr);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
                return ret;
            }
        }

        /// <summary>
        /// Gets/Sets Specifies a speed factor for the animation.
        /// The speed factor is a multiplier of the normal velocity of the animation.
        /// Values between[0, 1] will slow down the animation and values above one will speed up the animation.
        /// It is also possible to specify a negative multiplier to play the animation in reverse.
        /// </summary>
        public float SpeedFactor
        {
            set
            {
                NDalicPINVOKE.Animation_SetSpeedFactor(swigCPtr, value);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            }
            get
            {
                float ret = NDalicPINVOKE.Animation_GetSpeedFactor(swigCPtr);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
                return ret;
            }
        }

        /// <summary>
        /// Gets/Sets the playing range.
        /// Animation will play between the values specified. Both values(range.x and range.y ) should be between 0-1,
        /// otherwise they will be ignored.If the range provided is not in proper order(minimum, maximum ), it will be reordered.
        /// </summary>
        public RelativeVector2 PlayRange
        {
            set
            {
                NDalicPINVOKE.Animation_SetPlayRange(swigCPtr, Vector2.getCPtr(value));
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            }
            get
            {
                Vector2 ret = new Vector2(NDalicPINVOKE.Animation_GetPlayRange(swigCPtr), true);
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
                return ret;
            }
        }

        /// <summary>
        /// Animates a property value by a relative amount.
        /// The default alpha function will be used.
        /// The effect will start & end when the animation begins & ends.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="relativeValue">The property value will change by this amount</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimateBy(Actor target, string property, object relativeValue, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            dynamic obj = (object)relativeValue;

            if (alphaFunction != null)
            {
                AnimateBy(_prop, new PropertyValue(obj), alphaFunction);
            }
            else
            {
                AnimateBy(_prop, new PropertyValue(obj));
            }
        }

        /// <summary>
        /// Animates a property value by a relative amount.
        /// The default alpha function will be used.
        /// The effect will start & end when the animation begins & ends.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="relativeValue">The property value will change by this amount</param>
        /// <param name="startTime">Start time of animation</param>
        /// <param name="endTime">End time of animation</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimateBy(Actor target, string property, object relativeValue, int startTime, int endTime, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            dynamic obj = (object)relativeValue;

            if (alphaFunction != null)
            {
                Tizen.NUI.TimePeriod time = new Tizen.NUI.TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
                AnimateBy(_prop, new PropertyValue(obj), alphaFunction, time);
            }
            else
            {
                Tizen.NUI.TimePeriod time = new Tizen.NUI.TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
                AnimateBy(_prop, new PropertyValue(obj), time);
            }
        }

        /// <summary>
        /// Animates a property to a destination value.
        /// The default alpha function will be used.
        /// The effect will start & end when the animation begins & ends.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="destinationValue">The destination value</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimateTo(Actor target, string property, object destinationValue, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            dynamic obj = (object)destinationValue;

            if (alphaFunction != null)
            {
                AnimateTo(_prop, new PropertyValue(obj), alphaFunction);
            }
            else
            {
                AnimateTo(_prop, new PropertyValue(obj));
            }
        }

        /// <summary>
        /// Animates a property to a destination value.
        /// The default alpha function will be used.
        /// The effect will start & end when the animation begins & ends.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="destinationValue">The destination value</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        /// <param name="startTime">Start time of animation</param>
        /// <param name="endTime">End time of animation</param>
        /// <param name="alphaFunction"></param>
        public void AnimateTo(Actor target, string property, object destinationValue, int startTime, int endTime, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            dynamic obj = (object)destinationValue;

            if (alphaFunction != null)
            {
                Tizen.NUI.TimePeriod time = new Tizen.NUI.TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
                AnimateTo(_prop, new PropertyValue(obj), alphaFunction, time);
            }
            else
            {
                Tizen.NUI.TimePeriod time = new Tizen.NUI.TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
                AnimateTo(_prop, new PropertyValue(obj), time);
            }
        }

        /// <summary>
        /// Animates a property between keyframes.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="keyFrames">The set of time/value pairs between which to animate</param>
        /// <param name="interpolation">The method used to interpolate between values</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimateBetween(Actor target, string property, KeyFrames keyFrames, Interpolation interpolation = Interpolation.Linear, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            if (alphaFunction != null)
            {
                AnimateBetween(_prop, keyFrames, alphaFunction, interpolation);
            }
            else
            {
                AnimateBetween(_prop, keyFrames, interpolation);
            }
        }


        /// <summary>
        /// Animates a property between keyframes.
        /// </summary>
        /// <param name="target">The target object to animate</param>
        /// <param name="property">The target property to animate</param>
        /// <param name="keyFrames">The set of time/value pairs between which to animate</param>
        /// <param name="startTime">Start time of animation</param>
        /// <param name="endTime">End time of animation</param>
        /// <param name="interpolation">The method used to interpolate between values</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimateBetween(Actor target, string property, KeyFrames keyFrames, int startTime, int endTime, Interpolation interpolation = Interpolation.Linear, AlphaFunction alphaFunction = null)
        {
            string _str1 = property.Substring(0, 1);
            string _str2 = property.Substring(1);
            string _str = _str1.ToLower() + _str2;

            Property _prop = new Property(target, _str);
            if (_prop.propertyIndex == Property.INVALID_INDEX)
            {
                throw new System.Exception("second argument string property is invalid parameter!");
            }

            Tizen.NUI.TimePeriod time = new Tizen.NUI.TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
            if (alphaFunction != null)
            {
                AnimateBetween(_prop, keyFrames, alphaFunction, time, interpolation);
            }
            else
            {
                AnimateBetween(_prop, keyFrames, time, interpolation);
            }
        }

        /// <summary>
        /// Animates an actor's position and orientation through a predefined path.
        /// The actor will rotate to orient the supplied forward vector with the path's tangent. 
        /// If forward is the zero vector then no rotation will happen.
        /// </summary>
        /// <param name="actor">The actor to animate</param>
        /// <param name="path">It defines position and orientation</param>
        /// <param name="forward">The vector (in local space coordinate system) that will be oriented with the path's tangent direction</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimatePath(Actor actor, Path path, Vector3 forward, AlphaFunction alphaFunction = null)
        {
            if (alphaFunction == null)
            {
                Animate(actor, path, forward);
            }
            else
            {
                Animate(actor, path, forward, alphaFunction);
            }
        }

        /// <summary>
        /// Animates an actor's position and orientation through a predefined path.
        /// The actor will rotate to orient the supplied forward vector with the path's tangent. 
        /// If forward is the zero vector then no rotation will happen.
        /// </summary>
        /// <param name="actor">The actor to animate</param>
        /// <param name="path">It defines position and orientation</param>
        /// <param name="forward">The vector (in local space coordinate system) that will be oriented with the path's tangent direction</param>
        /// <param name="startTime">Start time of animation</param>
        /// <param name="endTime">End time of animation</param>
        /// <param name="alphaFunction">The alpha function to apply</param>
        public void AnimatePath(Actor actor, Path path, Vector3 forward, int startTime, int endTime, AlphaFunction alphaFunction = null)
        {
            TimePeriod time = new TimePeriod(MilliSecondsToSeconds(startTime), MilliSecondsToSeconds(endTime - startTime));
            if (alphaFunction == null)
            {
                Animate(actor, path, forward, time);
            }
            else
            {
                Animate(actor, path, forward, alphaFunction, time);
            }
        }

        /// <summary>
        /// Creates an initialized Animation.
        /// The animation will not loop.
        /// The default end action is "Cancel".
        /// The default alpha function is linear.
        /// </summary>
        public Animation() : this(NDalicPINVOKE.Animation_New(0.0f), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Animation(float durationSeconds) : this(NDalicPINVOKE.Animation_New(durationSeconds), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();

        }

        /// <summary>
        /// Downcasts a handle to Animation handle.
        /// If handle points to an Animation object, the downcast produces valid handle.
        /// If not, the returned handle is left uninitialized.
        /// </summary>
        /// <param name="handle">Handle to an object</param>
        /// <returns>Handle to an Animation object or an uninitialized handle</returns>
        public static Animation DownCast(BaseHandle handle)
        {
            Animation ret = new Animation(NDalicPINVOKE.Animation_DownCast(BaseHandle.getCPtr(handle)), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Animation(Animation handle) : this(NDalicPINVOKE.new_Animation__SWIG_1(Animation.getCPtr(handle)), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Animation Assign(Animation rhs)
        {
            Animation ret = new Animation(NDalicPINVOKE.Animation_Assign(swigCPtr, Animation.getCPtr(rhs)), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetDuration(float seconds)
        {
            NDalicPINVOKE.Animation_SetDuration(swigCPtr, seconds);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal float GetDuration()
        {
            float ret = NDalicPINVOKE.Animation_GetDuration(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetLooping(bool looping)
        {
            NDalicPINVOKE.Animation_SetLooping(swigCPtr, looping);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetLoopCount(int count)
        {
            NDalicPINVOKE.Animation_SetLoopCount(swigCPtr, count);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal int GetLoopCount()
        {
            int ret = NDalicPINVOKE.Animation_GetLoopCount(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal int GetCurrentLoop()
        {
            int ret = NDalicPINVOKE.Animation_GetCurrentLoop(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal bool IsLooping()
        {
            bool ret = NDalicPINVOKE.Animation_IsLooping(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetEndAction(Animation.EndActions action)
        {
            NDalicPINVOKE.Animation_SetEndAction(swigCPtr, (int)action);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Animation.EndActions GetEndAction()
        {
            Animation.EndActions ret = (Animation.EndActions)NDalicPINVOKE.Animation_GetEndAction(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetDisconnectAction(Animation.EndActions disconnectAction)
        {
            NDalicPINVOKE.Animation_SetDisconnectAction(swigCPtr, (int)disconnectAction);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Animation.EndActions GetDisconnectAction()
        {
            Animation.EndActions ret = (Animation.EndActions)NDalicPINVOKE.Animation_GetDisconnectAction(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetDefaultAlphaFunction(AlphaFunction alpha)
        {
            NDalicPINVOKE.Animation_SetDefaultAlphaFunction(swigCPtr, AlphaFunction.getCPtr(alpha));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal AlphaFunction GetDefaultAlphaFunction()
        {
            AlphaFunction ret = new AlphaFunction(NDalicPINVOKE.Animation_GetDefaultAlphaFunction(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetCurrentProgress(float progress)
        {
            NDalicPINVOKE.Animation_SetCurrentProgress(swigCPtr, progress);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal float GetCurrentProgress()
        {
            float ret = NDalicPINVOKE.Animation_GetCurrentProgress(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetSpeedFactor(float factor)
        {
            NDalicPINVOKE.Animation_SetSpeedFactor(swigCPtr, factor);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal float GetSpeedFactor()
        {
            float ret = NDalicPINVOKE.Animation_GetSpeedFactor(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetPlayRange(Vector2 range)
        {
            NDalicPINVOKE.Animation_SetPlayRange(swigCPtr, Vector2.getCPtr(range));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector2 GetPlayRange()
        {
            Vector2 ret = new Vector2(NDalicPINVOKE.Animation_GetPlayRange(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Play the animation.
        /// </summary>
        public void Play()
        {
            NDalicPINVOKE.Animation_Play(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Plays the animation from a given point.
        /// The progress must be in the 0-1 interval or in the play range interval if defined 
        /// otherwise, it will be ignored.
        /// </summary>
        /// <param name="progress">A value between [0,1], or between the play range if specified, from where the animation should start playing</param>
        public void PlayFrom(float progress)
        {
            NDalicPINVOKE.Animation_PlayFrom(swigCPtr, progress);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Pauses the animation.
        /// </summary>
        public void Pause()
        {
            NDalicPINVOKE.Animation_Pause(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Animation.States GetState()
        {
            Animation.States ret = (Animation.States)NDalicPINVOKE.Animation_GetState(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Stops the animation.
        /// </summary>
        public void Stop()
        {
            NDalicPINVOKE.Animation_Stop(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Clears the animation.
        /// This disconnects any objects that were being animated, effectively stopping the animation.
        /// </summary>
        public void Clear()
        {
            NDalicPINVOKE.Animation_Clear(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal AnimationSignal FinishedSignal()
        {
            AnimationSignal ret = new AnimationSignal(NDalicPINVOKE.Animation_FinishedSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void AnimateBy(Property target, PropertyValue relativeValue)
        {
            NDalicPINVOKE.Animation_AnimateBy__SWIG_0(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(relativeValue));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBy(Property target, PropertyValue relativeValue, AlphaFunction alpha)
        {
            NDalicPINVOKE.Animation_AnimateBy__SWIG_1(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(relativeValue), AlphaFunction.getCPtr(alpha));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBy(Property target, PropertyValue relativeValue, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateBy__SWIG_2(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(relativeValue), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBy(Property target, PropertyValue relativeValue, AlphaFunction alpha, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateBy__SWIG_3(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(relativeValue), AlphaFunction.getCPtr(alpha), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateTo(Property target, PropertyValue destinationValue)
        {
            NDalicPINVOKE.Animation_AnimateTo__SWIG_0(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(destinationValue));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateTo(Property target, PropertyValue destinationValue, AlphaFunction alpha)
        {
            NDalicPINVOKE.Animation_AnimateTo__SWIG_1(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(destinationValue), AlphaFunction.getCPtr(alpha));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateTo(Property target, PropertyValue destinationValue, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateTo__SWIG_2(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(destinationValue), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateTo(Property target, PropertyValue destinationValue, AlphaFunction alpha, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateTo__SWIG_3(swigCPtr, Property.getCPtr(target), PropertyValue.getCPtr(destinationValue), AlphaFunction.getCPtr(alpha), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_0(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, Animation.Interpolation interpolation)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_1(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), (int)interpolation);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, AlphaFunction alpha)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_2(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), AlphaFunction.getCPtr(alpha));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, AlphaFunction alpha, Animation.Interpolation interpolation)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_3(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), AlphaFunction.getCPtr(alpha), (int)interpolation);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_4(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, TimePeriod period, Animation.Interpolation interpolation)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_5(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), TimePeriod.getCPtr(period), (int)interpolation);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, AlphaFunction alpha, TimePeriod period)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_6(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), AlphaFunction.getCPtr(alpha), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void AnimateBetween(Property target, KeyFrames keyFrames, AlphaFunction alpha, TimePeriod period, Animation.Interpolation interpolation)
        {
            NDalicPINVOKE.Animation_AnimateBetween__SWIG_7(swigCPtr, Property.getCPtr(target), KeyFrames.getCPtr(keyFrames), AlphaFunction.getCPtr(alpha), TimePeriod.getCPtr(period), (int)interpolation);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Animate(Actor actor, Path path, Vector3 forward)
        {
            NDalicPINVOKE.Animation_Animate__SWIG_0(swigCPtr, Actor.getCPtr(actor), Path.getCPtr(path), Vector3.getCPtr(forward));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Animate(Actor actor, Path path, Vector3 forward, AlphaFunction alpha)
        {
            NDalicPINVOKE.Animation_Animate__SWIG_1(swigCPtr, Actor.getCPtr(actor), Path.getCPtr(path), Vector3.getCPtr(forward), AlphaFunction.getCPtr(alpha));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Animate(Actor actor, Path path, Vector3 forward, TimePeriod period)
        {
            NDalicPINVOKE.Animation_Animate__SWIG_2(swigCPtr, Actor.getCPtr(actor), Path.getCPtr(path), Vector3.getCPtr(forward), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Animate(Actor actor, Path path, Vector3 forward, AlphaFunction alpha, TimePeriod period)
        {
            NDalicPINVOKE.Animation_Animate__SWIG_3(swigCPtr, Actor.getCPtr(actor), Path.getCPtr(path), Vector3.getCPtr(forward), AlphaFunction.getCPtr(alpha), TimePeriod.getCPtr(period));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Show(Actor actor, float delaySeconds)
        {
            NDalicPINVOKE.Animation_Show(swigCPtr, Actor.getCPtr(actor), delaySeconds);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Hide(Actor actor, float delaySeconds)
        {
            NDalicPINVOKE.Animation_Hide(swigCPtr, Actor.getCPtr(actor), delaySeconds);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Enumeration for what to do when the animation ends, is stopped, or is destroyed.
        /// Cancel : When the animation ends, the animated property values are saved.
        /// Discard : When the animation ends, the animated property values are forgotten.
        /// StopFinal : If the animation is stopped, the animated property values are saved as if the animation had run to completion, otherwise behaves like Cancel.
        /// </summary>
        public enum EndActions
        {
            Cancel,
            Discard,
            StopFinal
        }

        /// <summary>
        /// Enumeration for what interpolation method to use on key-frame animations.
        /// Linear : Values in between key frames are interpolated using a linear polynomial. (Default)
        /// Cubic : Values in between key frames are interpolated using a cubic polynomial.
        /// </summary>
        public enum Interpolation
        {
            Linear,
            Cubic
        }

        /// <summary>
        /// Enumeration for what state the animation is in.
        /// Note: Calling Reset() on this class will NOT reset the animation. It will call BaseHandle.Reset() which drops the object handle.
        /// </summary>
        public enum States
        {
            Stopped,
            Playing,
            Paused
        }

    }

}
