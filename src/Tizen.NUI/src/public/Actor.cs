// Copyright (c) 2017 Samsung Electronics Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// This File has been auto-generated by SWIG and then modified using DALi Ruby Scripts
// Some have been manually changed


namespace Tizen.NUI
{

    using System;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Actor is the primary object with which Dali applications interact.
    /// UI controls can be built by combining multiple actors.
    /// </summary>
    public class Actor : Handle
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;

        internal Actor(global::System.IntPtr cPtr, bool cMemoryOwn) : base(NDalicPINVOKE.Actor_SWIGUpcast(cPtr), cMemoryOwn)
        {
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Actor obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Actor()
        {
            DisposeQueue.Instance.Add(this);
        }

        /// <summary>
        /// To make Actor instance be disposed.
        /// </summary>
        public override void Dispose()
        {
            if (!Stage.IsInstalled())
            {
                DisposeQueue.Instance.Add(this);
                return;
            }

            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        NDalicPINVOKE.delete_Actor(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
                global::System.GC.SuppressFinalize(this);
                base.Dispose();
            }
        }

        internal static Actor GetActorFromPtr(global::System.IntPtr cPtr)
        {
            Actor ret = new Actor(cPtr, false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal IntPtr GetPtrfromActor()
        {
            return (IntPtr)swigCPtr;
        }

        /// <summary>
        ///  Retrieve the position of the Actor.
        ///  The coordinates are relative to the Actor's parent.
        /// </summary>
        public Position CurrentPosition
        {
            get
            {
                return GetCurrentPosition();
            }
        }

        /// <summary>
        ///  Retrieve the size of the Actor.
        ///  The coordinates are relative to the Actor's parent.
        /// </summary>
        public Size CurrentSize
        {
            get
            {
                return GetCurrentSize();
            }
        }

        /// <summary>
        /// Retrieves the actor's parent.
        /// </summary>
        public Actor Parent
        {
            get
            {
                return GetParent();
            }
        }

        /// <summary>
        /// Retrieves and sets the actor's opacity.
        /// </summary>
        public float Opacity
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.COLOR_ALPHA).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR_ALPHA, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Retrieves screen postion of actor's
        /// </summary>
        public Vector2 ScreenPosition
        {
            get
            {
                Vector2 temp = new Vector2(0.0f, 0.0f);
                GetProperty(Actor.Property.SCREEN_POSITION).Get(temp);
                return temp;
            }
        }

        /// <summary>
        /// Determines whether the anchor point should be used to determine the position of the actor.
        /// This is true by default. 
        /// Note: If false, then the top-left of the actor is used for the position.
        /// Setting this to false will allow scaling or rotation around the anchor-point without affecting the actor's position.
        /// </summary>
        public bool PositionUsesAnchorPoint
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.POSITION_USES_ANCHOR_POINT).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.POSITION_USES_ANCHOR_POINT, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Queries whether the actor is connected to the Stage.
        /// When an actor is connected, it will be directly or indirectly parented to the root Actor.
        /// </summary>
        public bool IsOnStage
        {
            get
            {
                return OnStage();
            }
        }

        /// <summary>
        /// Gets depth in the hierarchy for the actor.
        /// </summary>
        public int HierarchyDepth
        {
            get
            {
                return GetHierarchyDepth();
            }
        }

        /// <summary>
        ///  Sets the sibling order of the actor so depth position can be defined within the same parent. 
        ///  Note The initial value is 0.
        ///  Raise, Lower, RaiseToTop, LowerToBottom, RaiseAbove and LowerBelow will override the sibling order.
        ///  The values set by this Property will likely change.
        /// </summary>
        public int SiblingOrder
        {
            get
            {
                int temp = 0;
                GetProperty(Actor.Property.SIBLING_ORDER).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIBLING_ORDER, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Sets the size of an actor for Width and Height.
        /// Geometry can be scaled to fit within this area.
        /// This does not interfere with the actors scale factor.
        /// The actors default depth is the minimum of Width & Height.
        /// </summary>
        public Size2D Size2D
        {
            get
            {
                Size temp = new Size(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.SIZE).Get(temp);
                return new Size2D(temp);
            }
            set
            {
                SetProperty(Actor.Property.SIZE, new PropertyValue(new Size(value)));
            }
        }

        /// <summary>
        /// Sets the position of the Actor for X and Y.
        /// By default, sets the position vector between the parent origin and anchor point(default).
        /// If Position inheritance if disabled, sets the world position.
        /// </summary>
        public Position2D Position2D
        {
            get
            {
                Position temp = new Position(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.POSITION).Get(temp);
                return new Position2D(temp);
            }
            set
            {
                SetProperty(Actor.Property.POSITION, new PropertyValue(new Position(value)));
            }
        }

        /// <summary>
        /// Sets the visibility flag of an actor as true to be shown.
        /// Note This is an asynchronous method; the value written may not match a value subsequently read with Visible.
        /// If an actor's visibility flag is set to false, then the actor and its children will not be rendered.
        /// This is regardless of the individual visibility values of the children i.e.an actor will only be rendered if all of its parents have visibility set to true.
        /// </summary>
        public void Show()
        {
            SetVisible(true);
        }

        /// <summary>
        /// Sets the visibility flag of an actor as false to be hidden.
        /// </summary>
        public void Hide()
        {
            SetVisible(false);
        }

        /// <summary>
        /// Raise actor above the next highest level of actor(s).
        /// Note Sibling order of actors within the parent will be updated automatically.
        /// Initially actors added to a parent will have the same sibling order and shown in relation to insertion order.
        /// Raising this actor above actors with the same sibling order as each other will raise this actor above them.
        /// Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        public void Raise()
        {
            NDalicPINVOKE.Raise(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Lower the actor to underneath the level below actor(s).
        /// Note Sibling order of actors within the parent will be updated automatically.
        /// Lowering this actor below actors with the same sibling order as each other will lower this actor above them.
        /// Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        public void Lower()
        {
            NDalicPINVOKE.Lower(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Raise actor above all other actors.
        /// Note Sibling order of actors within the parent will be updated automatically.
        /// Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        public void RaiseToTop()
        {
            NDalicPINVOKE.RaiseToTop(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Lower actor to the bottom of all actors.
        /// Note Sibling order of actors within the parent will be updated automatically.
        /// Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        public void LowerToBottom()
        {
            NDalicPINVOKE.LowerToBottom(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        ///  Raise the actor to above the target actor.
        ///  Note Sibling order of actors within the parent will be updated automatically.
        ///  Actors on the level above the target actor will still be shown above this actor.
        ///  Raising this actor above actors with the same sibling order as each other will raise this actor above them.
        ///  Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        /// <param name="target">Will be raised above this actor</param>
        public void RaiseAbove(Actor target)
        {
            NDalicPINVOKE.RaiseAbove(swigCPtr, Actor.getCPtr(target));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Lower the actor to below the target actor.
        /// Note Sibling order of actors within the parent will be updated automatically.
        /// Lowering this actor below actors with the same sibling order as each other will lower this actor above them.
        /// Once a raise or lower API is used that actor will then have an exclusive sibling order independent of insertion.
        /// </summary>
        /// <param name="target">Will be lowered below this actor</param>
        public void LowerBelow(Actor target)
        {
            NDalicPINVOKE.RaiseAbove(swigCPtr, Actor.getCPtr(target));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }


        internal class Property : global::System.IDisposable
        {
            private global::System.Runtime.InteropServices.HandleRef swigCPtr;
            protected bool swigCMemOwn;

            internal Property(global::System.IntPtr cPtr, bool cMemoryOwn)
            {
                swigCMemOwn = cMemoryOwn;
                swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
            }

            internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Property obj)
            {
                return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
            }

            ~Property()
            {
                Dispose();
            }

            public virtual void Dispose()
            {
                lock (this)
                {
                    if (swigCPtr.Handle != global::System.IntPtr.Zero)
                    {
                        if (swigCMemOwn)
                        {
                            swigCMemOwn = false;
                            NDalicPINVOKE.delete_Actor_Property(swigCPtr);
                        }
                        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                    }
                    global::System.GC.SuppressFinalize(this);
                }
            }

            internal static readonly int SIBLING_ORDER = NDalicManualPINVOKE.Actor_Property_SIBLING_ORDER_get();
            internal static readonly int OPACITY = NDalicManualPINVOKE.Actor_Property_OPACITY_get();
            internal static readonly int SCREEN_POSITION = NDalicManualPINVOKE.Actor_Property_SCREEN_POSITION_get();
            internal static readonly int POSITION_USES_ANCHOR_POINT = NDalicManualPINVOKE.Actor_Property_POSITION_USES_ANCHOR_POINT_get();

            internal Property() : this(NDalicPINVOKE.new_Actor_Property(), true)
            {
                if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            }

            internal static readonly int PARENT_ORIGIN = NDalicPINVOKE.Actor_Property_PARENT_ORIGIN_get();
            internal static readonly int PARENT_ORIGIN_X = NDalicPINVOKE.Actor_Property_PARENT_ORIGIN_X_get();
            internal static readonly int PARENT_ORIGIN_Y = NDalicPINVOKE.Actor_Property_PARENT_ORIGIN_Y_get();
            internal static readonly int PARENT_ORIGIN_Z = NDalicPINVOKE.Actor_Property_PARENT_ORIGIN_Z_get();
            internal static readonly int ANCHOR_POINT = NDalicPINVOKE.Actor_Property_ANCHOR_POINT_get();
            internal static readonly int ANCHOR_POINT_X = NDalicPINVOKE.Actor_Property_ANCHOR_POINT_X_get();
            internal static readonly int ANCHOR_POINT_Y = NDalicPINVOKE.Actor_Property_ANCHOR_POINT_Y_get();
            internal static readonly int ANCHOR_POINT_Z = NDalicPINVOKE.Actor_Property_ANCHOR_POINT_Z_get();
            internal static readonly int SIZE = NDalicPINVOKE.Actor_Property_SIZE_get();
            internal static readonly int SIZE_WIDTH = NDalicPINVOKE.Actor_Property_SIZE_WIDTH_get();
            internal static readonly int SIZE_HEIGHT = NDalicPINVOKE.Actor_Property_SIZE_HEIGHT_get();
            internal static readonly int SIZE_DEPTH = NDalicPINVOKE.Actor_Property_SIZE_DEPTH_get();
            internal static readonly int POSITION = NDalicPINVOKE.Actor_Property_POSITION_get();
            internal static readonly int POSITION_X = NDalicPINVOKE.Actor_Property_POSITION_X_get();
            internal static readonly int POSITION_Y = NDalicPINVOKE.Actor_Property_POSITION_Y_get();
            internal static readonly int POSITION_Z = NDalicPINVOKE.Actor_Property_POSITION_Z_get();
            internal static readonly int WORLD_POSITION = NDalicPINVOKE.Actor_Property_WORLD_POSITION_get();
            internal static readonly int WORLD_POSITION_X = NDalicPINVOKE.Actor_Property_WORLD_POSITION_X_get();
            internal static readonly int WORLD_POSITION_Y = NDalicPINVOKE.Actor_Property_WORLD_POSITION_Y_get();
            internal static readonly int WORLD_POSITION_Z = NDalicPINVOKE.Actor_Property_WORLD_POSITION_Z_get();
            internal static readonly int ORIENTATION = NDalicPINVOKE.Actor_Property_ORIENTATION_get();
            internal static readonly int WORLD_ORIENTATION = NDalicPINVOKE.Actor_Property_WORLD_ORIENTATION_get();
            internal static readonly int SCALE = NDalicPINVOKE.Actor_Property_SCALE_get();
            internal static readonly int SCALE_X = NDalicPINVOKE.Actor_Property_SCALE_X_get();
            internal static readonly int SCALE_Y = NDalicPINVOKE.Actor_Property_SCALE_Y_get();
            internal static readonly int SCALE_Z = NDalicPINVOKE.Actor_Property_SCALE_Z_get();
            internal static readonly int WORLD_SCALE = NDalicPINVOKE.Actor_Property_WORLD_SCALE_get();
            internal static readonly int VISIBLE = NDalicPINVOKE.Actor_Property_VISIBLE_get();
            internal static readonly int COLOR = NDalicPINVOKE.Actor_Property_COLOR_get();
            internal static readonly int COLOR_RED = NDalicPINVOKE.Actor_Property_COLOR_RED_get();
            internal static readonly int COLOR_GREEN = NDalicPINVOKE.Actor_Property_COLOR_GREEN_get();
            internal static readonly int COLOR_BLUE = NDalicPINVOKE.Actor_Property_COLOR_BLUE_get();
            internal static readonly int COLOR_ALPHA = NDalicPINVOKE.Actor_Property_COLOR_ALPHA_get();
            internal static readonly int WORLD_COLOR = NDalicPINVOKE.Actor_Property_WORLD_COLOR_get();
            internal static readonly int WORLD_MATRIX = NDalicPINVOKE.Actor_Property_WORLD_MATRIX_get();
            internal static readonly int NAME = NDalicPINVOKE.Actor_Property_NAME_get();
            internal static readonly int SENSITIVE = NDalicPINVOKE.Actor_Property_SENSITIVE_get();
            internal static readonly int LEAVE_REQUIRED = NDalicPINVOKE.Actor_Property_LEAVE_REQUIRED_get();
            internal static readonly int INHERIT_ORIENTATION = NDalicPINVOKE.Actor_Property_INHERIT_ORIENTATION_get();
            internal static readonly int INHERIT_SCALE = NDalicPINVOKE.Actor_Property_INHERIT_SCALE_get();
            internal static readonly int COLOR_MODE = NDalicPINVOKE.Actor_Property_COLOR_MODE_get();
            internal static readonly int POSITION_INHERITANCE = NDalicPINVOKE.Actor_Property_POSITION_INHERITANCE_get();
            internal static readonly int DRAW_MODE = NDalicPINVOKE.Actor_Property_DRAW_MODE_get();
            internal static readonly int SIZE_MODE_FACTOR = NDalicPINVOKE.Actor_Property_SIZE_MODE_FACTOR_get();
            internal static readonly int WIDTH_RESIZE_POLICY = NDalicPINVOKE.Actor_Property_WIDTH_RESIZE_POLICY_get();
            internal static readonly int HEIGHT_RESIZE_POLICY = NDalicPINVOKE.Actor_Property_HEIGHT_RESIZE_POLICY_get();
            internal static readonly int SIZE_SCALE_POLICY = NDalicPINVOKE.Actor_Property_SIZE_SCALE_POLICY_get();
            internal static readonly int WIDTH_FOR_HEIGHT = NDalicPINVOKE.Actor_Property_WIDTH_FOR_HEIGHT_get();
            internal static readonly int HEIGHT_FOR_WIDTH = NDalicPINVOKE.Actor_Property_HEIGHT_FOR_WIDTH_get();
            internal static readonly int PADDING = NDalicPINVOKE.Actor_Property_PADDING_get();
            internal static readonly int MINIMUM_SIZE = NDalicPINVOKE.Actor_Property_MINIMUM_SIZE_get();
            internal static readonly int MAXIMUM_SIZE = NDalicPINVOKE.Actor_Property_MAXIMUM_SIZE_get();
            internal static readonly int INHERIT_POSITION = NDalicPINVOKE.Actor_Property_INHERIT_POSITION_get();
            internal static readonly int CLIPPING_MODE = NDalicPINVOKE.Actor_Property_CLIPPING_MODE_get();

        }

        /// <summary>
        /// Creates an initialized Actor.
        /// </summary>
        public Actor() : this(NDalicPINVOKE.Actor_New(), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();

        }

        /// <summary>
        /// Downcasts a handle to Actor handle. 
        /// If handle points to an Actor object, the downcast produces valid handle.
        /// If not, the returned handle is left uninitialized.   *
        /// </summary>
        /// <param name="handle">handle to An object</param>
        /// <returns>handle to a Actor object or an uninitialized handle</returns>
        public new static Actor DownCast(BaseHandle handle)
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_DownCast(BaseHandle.getCPtr(handle)), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Actor(Actor copy) : this(NDalicPINVOKE.new_Actor__SWIG_1(Actor.getCPtr(copy)), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Actor Assign(Actor rhs)
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_Assign(swigCPtr, Actor.getCPtr(rhs)), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal string GetName()
        {
            string ret = NDalicPINVOKE.Actor_GetName(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetName(string name)
        {
            NDalicPINVOKE.Actor_SetName(swigCPtr, name);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal uint GetId()
        {
            uint ret = NDalicPINVOKE.Actor_GetId(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal bool IsRoot()
        {
            bool ret = NDalicPINVOKE.Actor_IsRoot(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal bool OnStage()
        {
            bool ret = NDalicPINVOKE.Actor_OnStage(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal bool IsLayer()
        {
            bool ret = NDalicPINVOKE.Actor_IsLayer(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Layer GetLayer()
        {
            Layer ret = new Layer(NDalicPINVOKE.Actor_GetLayer(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Adds a child Actor to this Actor.
        /// Precondition : This Actor(the parent) has been initialized. The child actor has been initialized. The child actor is not the same as the parent actor.
        /// PostCondition : The child will be referenced by its parent. This means that the child will be kept alive, even if the handle passed into this method is reset or destroyed.
        /// Note : If the child already has a parent, it will be removed from old parent and reparented to this actor. This may change child's position, color, scale etc as it now inherits them from this actor.
        /// </summary>
        /// <param name="child">The child</param>
        public void Add(Actor child)
        {
            NDalicPINVOKE.Actor_Add(swigCPtr, Actor.getCPtr(child));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Removes a child Actor from this Actor. If the actor was not a child of this actor, this is a no-op.
        /// Precondition : This Actor(the parent) has been initialized. The child actor is not the same as the parent actor.
        /// </summary>
        /// <param name="child">The child</param>
        public void Remove(Actor child)
        {
            NDalicPINVOKE.Actor_Remove(swigCPtr, Actor.getCPtr(child));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void Unparent()
        {
            NDalicPINVOKE.Actor_Unparent(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Retrieves the number of children held by the actor.
        /// Precondition :  The Actor has been initialized.
        /// </summary>
        /// <returns>The number of children</returns>
        public uint GetChildCount()
        {
            uint ret = NDalicPINVOKE.Actor_GetChildCount(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Retrieve and child actor by index.
        /// Precondition : The Actor has been initialized.
        /// </summary>
        /// <param name="index">The index of the child to retrieve</param>
        /// <returns>The actor for the given index or empty handle if children not initialized</returns>
        public Actor GetChildAt(uint index)
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_GetChildAt(swigCPtr, index), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Search through this actor's hierarchy for an actor with the given name.
        /// The actor itself is also considered in the search.
        ///Precondition :  The Actor has been initialized.
        /// </summary>
        /// <param name="actorName">The name of the actor to find</param>
        /// <returns>A handle to the actor if found, or an empty handle if not</returns>
        public Actor FindChildByName(string actorName)
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_FindChildByName(swigCPtr, actorName), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Actor FindChildById(uint id)
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_FindChildById(swigCPtr, id), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Actor GetParent()
        {
            Actor ret = new Actor(NDalicPINVOKE.Actor_GetParent(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetParentOrigin(Vector3 origin)
        {
            NDalicPINVOKE.Actor_SetParentOrigin(swigCPtr, Vector3.getCPtr(origin));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector3 GetCurrentParentOrigin()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetCurrentParentOrigin(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetAnchorPoint(Vector3 anchorPoint)
        {
            NDalicPINVOKE.Actor_SetAnchorPoint(swigCPtr, Vector3.getCPtr(anchorPoint));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector3 GetCurrentAnchorPoint()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetCurrentAnchorPoint(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetSize(float width, float height)
        {
            NDalicPINVOKE.Actor_SetSize__SWIG_0(swigCPtr, width, height);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetSize(float width, float height, float depth)
        {
            NDalicPINVOKE.Actor_SetSize__SWIG_1(swigCPtr, width, height, depth);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetSize(Vector2 size)
        {
            NDalicPINVOKE.Actor_SetSize__SWIG_2(swigCPtr, Vector2.getCPtr(size));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetSize(Vector3 size)
        {
            NDalicPINVOKE.Actor_SetSize__SWIG_3(swigCPtr, Vector3.getCPtr(size));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector3 GetTargetSize()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetTargetSize(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Size GetCurrentSize()
        {
            Size ret = new Size(NDalicPINVOKE.Actor_GetCurrentSize(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Returns the natural size of the actor.
        /// Deriving classes stipulate the natural size and by default an actor has a ZERO natural size.
        /// </summary>
        /// <returns>The actor's natural size</returns>
        public Vector3 GetNaturalSize()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetNaturalSize(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetPosition(float x, float y)
        {
            NDalicPINVOKE.Actor_SetPosition__SWIG_0(swigCPtr, x, y);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetPosition(float x, float y, float z)
        {
            NDalicPINVOKE.Actor_SetPosition__SWIG_1(swigCPtr, x, y, z);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetPosition(Vector3 position)
        {
            NDalicPINVOKE.Actor_SetPosition__SWIG_2(swigCPtr, Vector3.getCPtr(position));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetX(float x)
        {
            NDalicPINVOKE.Actor_SetX(swigCPtr, x);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetY(float y)
        {
            NDalicPINVOKE.Actor_SetY(swigCPtr, y);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetZ(float z)
        {
            NDalicPINVOKE.Actor_SetZ(swigCPtr, z);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void TranslateBy(Vector3 distance)
        {
            NDalicPINVOKE.Actor_TranslateBy(swigCPtr, Vector3.getCPtr(distance));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Position GetCurrentPosition()
        {
            Position ret = new Position(NDalicPINVOKE.Actor_GetCurrentPosition(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Vector3 GetCurrentWorldPosition()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetCurrentWorldPosition(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetInheritPosition(bool inherit)
        {
            NDalicPINVOKE.Actor_SetInheritPosition(swigCPtr, inherit);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal PositionInheritanceMode GetPositionInheritanceMode()
        {
            PositionInheritanceMode ret = (PositionInheritanceMode)NDalicPINVOKE.Actor_GetPositionInheritanceMode(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal bool IsPositionInherited()
        {
            bool ret = NDalicPINVOKE.Actor_IsPositionInherited(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetOrientation(Degree angle, Vector3 axis)
        {
            NDalicPINVOKE.Actor_SetOrientation__SWIG_0(swigCPtr, Degree.getCPtr(angle), Vector3.getCPtr(axis));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetOrientation(Radian angle, Vector3 axis)
        {
            NDalicPINVOKE.Actor_SetOrientation__SWIG_1(swigCPtr, Radian.getCPtr(angle), Vector3.getCPtr(axis));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetOrientation(Rotation orientation)
        {
            NDalicPINVOKE.Actor_SetOrientation__SWIG_2(swigCPtr, Rotation.getCPtr(orientation));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void RotateBy(Degree angle, Vector3 axis)
        {
            NDalicPINVOKE.Actor_RotateBy__SWIG_0(swigCPtr, Degree.getCPtr(angle), Vector3.getCPtr(axis));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void RotateBy(Radian angle, Vector3 axis)
        {
            NDalicPINVOKE.Actor_RotateBy__SWIG_1(swigCPtr, Radian.getCPtr(angle), Vector3.getCPtr(axis));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void RotateBy(Rotation relativeRotation)
        {
            NDalicPINVOKE.Actor_RotateBy__SWIG_2(swigCPtr, Rotation.getCPtr(relativeRotation));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Rotation GetCurrentOrientation()
        {
            Rotation ret = new Rotation(NDalicPINVOKE.Actor_GetCurrentOrientation(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetInheritOrientation(bool inherit)
        {
            NDalicPINVOKE.Actor_SetInheritOrientation(swigCPtr, inherit);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool IsOrientationInherited()
        {
            bool ret = NDalicPINVOKE.Actor_IsOrientationInherited(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Rotation GetCurrentWorldOrientation()
        {
            Rotation ret = new Rotation(NDalicPINVOKE.Actor_GetCurrentWorldOrientation(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetScale(float scale)
        {
            NDalicPINVOKE.Actor_SetScale__SWIG_0(swigCPtr, scale);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetScale(float scaleX, float scaleY, float scaleZ)
        {
            NDalicPINVOKE.Actor_SetScale__SWIG_1(swigCPtr, scaleX, scaleY, scaleZ);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetScale(Vector3 scale)
        {
            NDalicPINVOKE.Actor_SetScale__SWIG_2(swigCPtr, Vector3.getCPtr(scale));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void ScaleBy(Vector3 relativeScale)
        {
            NDalicPINVOKE.Actor_ScaleBy(swigCPtr, Vector3.getCPtr(relativeScale));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector3 GetCurrentScale()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetCurrentScale(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Vector3 GetCurrentWorldScale()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetCurrentWorldScale(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetInheritScale(bool inherit)
        {
            NDalicPINVOKE.Actor_SetInheritScale(swigCPtr, inherit);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool IsScaleInherited()
        {
            bool ret = NDalicPINVOKE.Actor_IsScaleInherited(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Matrix GetCurrentWorldMatrix()
        {
            Matrix ret = new Matrix(NDalicPINVOKE.Actor_GetCurrentWorldMatrix(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetVisible(bool visible)
        {
            NDalicPINVOKE.Actor_SetVisible(swigCPtr, visible);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool IsVisible()
        {
            bool ret = NDalicPINVOKE.Actor_IsVisible(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetOpacity(float opacity)
        {
            NDalicPINVOKE.Actor_SetOpacity(swigCPtr, opacity);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal float GetCurrentOpacity()
        {
            float ret = NDalicPINVOKE.Actor_GetCurrentOpacity(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetColor(Vector4 color)
        {
            NDalicPINVOKE.Actor_SetColor(swigCPtr, Vector4.getCPtr(color));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector4 GetCurrentColor()
        {
            Vector4 ret = new Vector4(NDalicPINVOKE.Actor_GetCurrentColor(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetColorMode(ColorMode colorMode)
        {
            NDalicPINVOKE.Actor_SetColorMode(swigCPtr, (int)colorMode);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal ColorMode GetColorMode()
        {
            ColorMode ret = (ColorMode)NDalicPINVOKE.Actor_GetColorMode(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Vector4 GetCurrentWorldColor()
        {
            Vector4 ret = new Vector4(NDalicPINVOKE.Actor_GetCurrentWorldColor(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetDrawMode(DrawModeType drawMode)
        {
            NDalicPINVOKE.Actor_SetDrawMode(swigCPtr, (int)drawMode);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal DrawModeType GetDrawMode()
        {
            DrawModeType ret = (DrawModeType)NDalicPINVOKE.Actor_GetDrawMode(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetSensitive(bool sensitive)
        {
            NDalicPINVOKE.Actor_SetSensitive(swigCPtr, sensitive);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool IsSensitive()
        {
            bool ret = NDalicPINVOKE.Actor_IsSensitive(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Converts screen coordinates into the actor's coordinate system using the default camera.
        /// Precondition : The Actor has been initialized.
        /// Note : The actor coordinates are relative to the top-left(0.0, 0.0, 0.5)
        /// </summary>
        /// <param name="localX">On return, the X-coordinate relative to the actor</param>
        /// <param name="localY">On return, the Y-coordinate relative to the actor</param>
        /// <param name="screenX">The screen X-coordinate</param>
        /// <param name="screenY">The screen Y-coordinate</param>
        /// <returns>True if the conversion succeeded</returns>
        public bool ScreenToLocal(out float localX, out float localY, float screenX, float screenY)
        {
            bool ret = NDalicPINVOKE.Actor_ScreenToLocal(swigCPtr, out localX, out localY, screenX, screenY);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetLeaveRequired(bool required)
        {
            NDalicPINVOKE.Actor_SetLeaveRequired(swigCPtr, required);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool GetLeaveRequired()
        {
            bool ret = NDalicPINVOKE.Actor_GetLeaveRequired(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetKeyboardFocusable(bool focusable)
        {
            NDalicPINVOKE.Actor_SetKeyboardFocusable(swigCPtr, focusable);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool IsKeyboardFocusable()
        {
            bool ret = NDalicPINVOKE.Actor_IsKeyboardFocusable(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetResizePolicy(ResizePolicyType policy, DimensionType dimension)
        {
            NDalicPINVOKE.Actor_SetResizePolicy(swigCPtr, (int)policy, (int)dimension);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal ResizePolicyType GetResizePolicy(DimensionType dimension)
        {
            ResizePolicyType ret = (ResizePolicyType)NDalicPINVOKE.Actor_GetResizePolicy(swigCPtr, (int)dimension);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetSizeScalePolicy(SizeScalePolicyType policy)
        {
            NDalicPINVOKE.Actor_SetSizeScalePolicy(swigCPtr, (int)policy);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal SizeScalePolicyType GetSizeScalePolicy()
        {
            SizeScalePolicyType ret = (SizeScalePolicyType)NDalicPINVOKE.Actor_GetSizeScalePolicy(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Sets the relative to parent size factor of the actor.
        /// This factor is only used when ResizePolicy is set to either
        /// This actor's size is set to the actor's size multiplied by or added to this factor, depending on ResizePolicy
        /// Precondition : The Actor has been initialized.
        /// </summary>
        /// <param name="factor">A Vector3 representing the relative factor to be applied to each axis</param>
        public void SetSizeModeFactor(Vector3 factor)
        {
            NDalicPINVOKE.Actor_SetSizeModeFactor(swigCPtr, Vector3.getCPtr(factor));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector3 GetSizeModeFactor()
        {
            Vector3 ret = new Vector3(NDalicPINVOKE.Actor_GetSizeModeFactor(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Calculates the height of the actor given a width.
        /// The natural size is used for default calculation. 
        /// size 0 is treated as aspect ratio 1:1.
        /// </summary>
        /// <param name="width">Width to use</param>
        /// <returns>the height based on the width</returns>
        public float GetHeightForWidth(float width)
        {
            float ret = NDalicPINVOKE.Actor_GetHeightForWidth(swigCPtr, width);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Calculates the width of the actor given a height.
        /// The natural size is used for default calculation.
        /// size 0 is treated as aspect ratio 1:1.
        /// </summary>
        /// <param name="height">Height to use</param>
        /// <returns>the width based on the height</returns>
        public float GetWidthForHeight(float height)
        {
            float ret = NDalicPINVOKE.Actor_GetWidthForHeight(swigCPtr, height);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public float GetRelayoutSize(DimensionType dimension)
        {
            float ret = NDalicPINVOKE.Actor_GetRelayoutSize(swigCPtr, (int)dimension);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Sets the padding for use in layout.
        /// </summary>
        /// <param name="padding">padding Padding for the actor</param>
        public void SetPadding(PaddingType padding)
        {
            NDalicPINVOKE.Actor_SetPadding(swigCPtr, PaddingType.getCPtr(padding));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Returns the value of the padding.
        /// </summary>
        /// <param name="paddingOut">The returned padding data</param>
        public void GetPadding(PaddingType paddingOut)
        {
            NDalicPINVOKE.Actor_GetPadding(swigCPtr, PaddingType.getCPtr(paddingOut));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void SetMinimumSize(Vector2 size)
        {
            NDalicPINVOKE.Actor_SetMinimumSize(swigCPtr, Vector2.getCPtr(size));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector2 GetMinimumSize()
        {
            Vector2 ret = new Vector2(NDalicPINVOKE.Actor_GetMinimumSize(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void SetMaximumSize(Vector2 size)
        {
            NDalicPINVOKE.Actor_SetMaximumSize(swigCPtr, Vector2.getCPtr(size));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal Vector2 GetMaximumSize()
        {
            Vector2 ret = new Vector2(NDalicPINVOKE.Actor_GetMaximumSize(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal int GetHierarchyDepth()
        {
            int ret = NDalicPINVOKE.Actor_GetHierarchyDepth(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal uint AddRenderer(Renderer renderer)
        {
            uint ret = NDalicPINVOKE.Actor_AddRenderer(swigCPtr, Renderer.getCPtr(renderer));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal uint GetRendererCount()
        {
            uint ret = NDalicPINVOKE.Actor_GetRendererCount(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal Renderer GetRendererAt(uint index)
        {
            Renderer ret = new Renderer(NDalicPINVOKE.Actor_GetRendererAt(swigCPtr, index), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal void RemoveRenderer(Renderer renderer)
        {
            NDalicPINVOKE.Actor_RemoveRenderer__SWIG_0(swigCPtr, Renderer.getCPtr(renderer));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal void RemoveRenderer(uint index)
        {
            NDalicPINVOKE.Actor_RemoveRenderer__SWIG_1(swigCPtr, index);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal SWIGTYPE_p_Dali__SignalT_bool_fDali__Actor_Dali__TouchEvent_const_RF_t TouchedSignal()
        {
            SWIGTYPE_p_Dali__SignalT_bool_fDali__Actor_Dali__TouchEvent_const_RF_t ret = new SWIGTYPE_p_Dali__SignalT_bool_fDali__Actor_Dali__TouchEvent_const_RF_t(NDalicPINVOKE.Actor_TouchedSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorTouchDataSignal TouchSignal()
        {
            ActorTouchDataSignal ret = new ActorTouchDataSignal(NDalicPINVOKE.Actor_TouchSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorHoverSignal HoveredSignal()
        {
            ActorHoverSignal ret = new ActorHoverSignal(NDalicPINVOKE.Actor_HoveredSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorWheelSignal WheelEventSignal()
        {
            ActorWheelSignal ret = new ActorWheelSignal(NDalicPINVOKE.Actor_WheelEventSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorSignal OnStageSignal()
        {
            ActorSignal ret = new ActorSignal(NDalicPINVOKE.Actor_OnStageSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorSignal OffStageSignal()
        {
            ActorSignal ret = new ActorSignal(NDalicPINVOKE.Actor_OffStageSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ActorSignal OnRelayoutSignal()
        {
            ActorSignal ret = new ActorSignal(NDalicPINVOKE.Actor_OnRelayoutSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Gets/Sets the origin of an actor, within its parent's area.
        /// This is expressed in unit coordinates, such that(0.0, 0.0, 0.5) is the top-left corner of the parent, and(1.0, 1.0, 0.5) is the bottom-right corner.
        /// The default parent-origin is ParentOrigin.TopLeft (0.0, 0.0, 0.5).
        /// An actor's position is the distance between this origin, and the actor's anchor-point.
        /// Precondition : The Actor has been initialized.
        /// </summary>
        public Position ParentOrigin
        {
            get
            {
                Position temp = new Position(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.PARENT_ORIGIN).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.PARENT_ORIGIN, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the anchor-point of an actor. 
        /// This is expressed in unit coordinates, such that (0.0, 0.0, 0.5) is the top-left corner of the actor, and(1.0, 1.0, 0.5) is the bottom-right corner.
        /// The default anchor point is AnchorPoint.Center (0.5, 0.5, 0.5).
        /// An actor position is the distance between its parent-origin and this anchor-point.
        /// An actor's orientation is the rotation from its default orientation, the rotation is centered around its anchor-point.
        /// Precondition : The Actor has been initialized.
        /// </summary>
        public Position AnchorPoint
        {
            get
            {
                Position temp = new Position(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.ANCHOR_POINT).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.ANCHOR_POINT, new Tizen.NUI.PropertyValue(value));
            }
        }


        /// <summary>
        /// Gets/Sets the size of an actor.
        /// Geometry can be scaled to fit within this area.
        /// This does not interfere with the actors scale factor.
        /// </summary>
        public Size Size
        {
            get
            {
                Size temp = new Size(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.SIZE).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIZE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the size width of an actor.
        /// </summary>
        public float SizeWidth
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SIZE_WIDTH).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIZE_WIDTH, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the size height of an actor.
        /// </summary>
        public float SizeHeight
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SIZE_HEIGHT).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIZE_HEIGHT, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the size depth of an actor.
        /// </summary>
        public float SizeDepth
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SIZE_DEPTH).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIZE_DEPTH, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the position of the Actor.
        /// By default, sets the position vector between the parent origin and anchor point(default).
        /// If Position inheritance if disabled, sets the world position.
        /// </summary>
        public Position Position
        {
            get
            {
                Position temp = new Position(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.POSITION).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.POSITION, new Tizen.NUI.PropertyValue(value));
            }
        }


        /// <summary>
        /// Gets/Sets the position x of the Actor.
        /// </summary>
        public float PositionX
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.POSITION_X).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.POSITION_X, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the position y of the Actor.
        /// </summary>
        public float PositionY
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.POSITION_Y).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.POSITION_Y, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the position z of the Actor.
        /// </summary>
        public float PositionZ
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.POSITION_Z).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.POSITION_Z, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the world position of the Actor.
        /// </summary>
        public Vector3 WorldPosition
        {
            get
            {
                Vector3 temp = new Vector3(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.WORLD_POSITION).Get(temp);
                return temp;
            }
        }

        /// <summary>
        /// Gets/Sets the orientation of the Actor.
        /// An actor's orientation is the rotation from its default orientation, and the rotation is centered around its anchor-point.
        /// Note: This is an asynchronous method.
        /// </summary>
        public Rotation Orientation
        {
            get
            {
                Rotation temp = new Rotation();
                GetProperty(Actor.Property.ORIENTATION).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.ORIENTATION, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the world orientation of the Actor.
        /// </summary>
        public Rotation WorldOrientation
        {
            get
            {
                Rotation temp = new Rotation();
                GetProperty(Actor.Property.WORLD_ORIENTATION).Get(temp);
                return temp;
            }
        }

        /// <summary>
        /// Gets/Sets the scale factor applied to an actor.
        /// Note : This is an asynchronous method.
        /// </summary>
        public Vector3 Scale
        {
            get
            {
                Vector3 temp = new Vector3(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.SCALE).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SCALE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the scale x factor applied to an actor.
        /// </summary>
        public float ScaleX
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SCALE_X).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SCALE_X, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the scale y factor applied to an actor.
        /// </summary>
        public float ScaleY
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SCALE_Y).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SCALE_Y, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the scale z factor applied to an actor.
        /// </summary>
        public float ScaleZ
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.SCALE_Z).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SCALE_Z, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets the world scale of Actor.
        /// </summary>
        public Vector3 WorldScale
        {
            get
            {
                Vector3 temp = new Vector3(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.WORLD_SCALE).Get(temp);
                return temp;
            }
        }

        /// <summary>
        /// Retrieves the visibility flag of an actor.
        /// Note : If an actor is not visible, then the actor and its children will not be rendered.
        /// This is regardless of the individual visibility values of the children i.e.an actor will only be rendered if all of its parents have visibility set to true.
        /// </summary>
        public bool Visible
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.VISIBLE).Get(ref temp);
                return temp;
            }
            /* only get is required : removed
            set
            {
                SetProperty(Actor.Property.VISIBLE, new Tizen.NUI.PropertyValue(value));
            }
            */
        }

        /// <summary>
        /// Gets/Sets the actor's mix color; this is an RGBA value.
        /// The final color of the actor depends on its color mode.
        /// Note : This is an asynchronous method.
        /// </summary>
        public Color MixColor
        {
            get
            {
                Color temp = new Color(0.0f, 0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.COLOR).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the actor's mix color red.
        /// </summary>
        public float ColorRed
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.COLOR_RED).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR_RED, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the actor's mix color green.
        /// </summary>
        public float ColorGreen
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.COLOR_GREEN).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR_GREEN, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the actor's mix color blue
        /// </summary>
        public float ColorBlue
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.COLOR_BLUE).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR_BLUE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the actor's mix color alpha.
        /// </summary>
        public float ColorAlpha
        {
            get
            {
                float temp = 0.0f;
                GetProperty(Actor.Property.COLOR_ALPHA).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.COLOR_ALPHA, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets the actor's world color.
        /// </summary>
        public Color WorldColor
        {
            get
            {
                Color temp = new Color(0.0f, 0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.WORLD_COLOR).Get(temp);
                return temp;
            }
        }

        /// <summary>
        /// Gets/Sets the Actor's name.
        /// </summary>
        public string Name
        {
            get
            {
                string temp;
                GetProperty(Actor.Property.NAME).Get(out temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.NAME, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the status of whether an actor should emit touch or hover signals.
        /// </summary>
        public bool Sensitive
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.SENSITIVE).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SENSITIVE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the status of whether the actor should receive a notification when touch or hover motion events leave the boundary of the actor.
        /// </summary>
        public bool LeaveRequired
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.LEAVE_REQUIRED).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.LEAVE_REQUIRED, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the status of whether a child actor inherits it's parent's orientation.
        /// </summary>
        public bool InheritOrientation
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.INHERIT_ORIENTATION).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.INHERIT_ORIENTATION, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the status of whether a child actor inherits it's parent's scale.
        /// </summary>
        public bool InheritScale
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.INHERIT_SCALE).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.INHERIT_SCALE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the actor's color mode.
        /// This specifies whether the Actor uses its own color, or inherits its parent color.
        /// The default is UseOwnMultiplyParentAlpha.
        /// </summary>
        public ColorMode ColorMode
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.COLOR_MODE).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "ColorMode get error!");
                }
                switch (temp)
                {
                    case "USE_OWN_COLOR":
                    return ColorMode.UseOwnColor;
                    case "USE_PARENT_COLOR":
                    return ColorMode.UseParentColor;
                    case "USE_OWN_MULTIPLY_PARENT_COLOR":
                    return ColorMode.UseOwnMultiplyParentColor;
                    case "USE_OWN_MULTIPLY_PARENT_ALPHA":
                    return ColorMode.UseOwnMultiplyParentAlpha;
                    default:
                    return ColorMode.UseOwnMultiplyParentAlpha;
                }
            }
            set
            {
                SetProperty(Actor.Property.COLOR_MODE, new Tizen.NUI.PropertyValue((int)value));
            }
        }


        /// <summary>
        /// Gets/Sets the status of how the actor and its children should be drawn.
        /// Not all actors are renderable, but DrawMode can be inherited from any actor.
        /// If an object is in a 3D layer, it will be depth-tested against other objects in the world i.e. it may be obscured if other objects are in front.
        /// If DrawMode.Overlay2D is used, the actor and its children will be drawn as a 2D overlay.
        /// Overlay actors are drawn in a separate pass, after all non-overlay actors within the Layer.
        /// For overlay actors, the drawing order is with respect to tree levels of Actors, and depth-testing will not be used.
        /// </summary>
        public DrawModeType DrawMode
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.DRAW_MODE).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "DrawMode get error!");
                }
                switch (temp)
                {
                    case "NORMAL":
                    return DrawModeType.Normal;
                    case "OVERLAY_2D":
                    return DrawModeType.Overlay2D;
                    case "STENCIL":
                    return DrawModeType.Stencil;
                    default:
                    return DrawModeType.Normal;
                }
            }
            set
            {
                SetProperty(Actor.Property.DRAW_MODE, new Tizen.NUI.PropertyValue((int)value));
            }
        }

        /// <summary>
        /// Gets/Sets the relative to parent size factor of the actor.
        /// This factor is only used when ResizePolicyType is set to either: ResizePolicyType.SizeRelativeToParent or ResizePolicyType.SizeFixedOffsetFromParent.
        /// This actor's size is set to the actor's size multiplied by or added to this factor, depending on ResizePolicyType.
        /// </summary>
        public Vector3 SizeModeFactor
        {
            get
            {
                Vector3 temp = new Vector3(0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.SIZE_MODE_FACTOR).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.SIZE_MODE_FACTOR, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the width resize policy to be used for the given dimension(s).
        /// </summary>
        public ResizePolicyType WidthResizePolicy
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.WIDTH_RESIZE_POLICY).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "WidthResizePolicy get error!");
                }
                switch (temp)
                {
                    case "FIXED":
                    return ResizePolicyType.Fixed;
                    case "USE_NATURAL_SIZE":
                    return ResizePolicyType.UseNaturalSize;
                    case "FILL_TO_PARENT":
                    return ResizePolicyType.FillToParent;
                    case "SIZE_RELATIVE_TO_PARENT":
                    return ResizePolicyType.SizeRelativeToParent;
                    case "SIZE_FIXED_OFFSET_FROM_PARENT":
                    return ResizePolicyType.SizeFixedOffsetFromParent;
                    case "FIT_TO_CHILDREN":
                    return ResizePolicyType.FitToChildren;
                    case "DIMENSION_DEPENDENCY":
                    return ResizePolicyType.DimensionDependency;
                    case "USE_ASSIGNED_SIZE":
                    return ResizePolicyType.UseAssignedSize;
                    default:
                    return ResizePolicyType.Fixed;
                }
            }
            set
            {
                SetProperty(Actor.Property.WIDTH_RESIZE_POLICY, new Tizen.NUI.PropertyValue((int)value));
            }
        }

        /// <summary>
        /// Gets/Sets the height resize policy to be used for the given dimension(s).
        /// </summary>
        public ResizePolicyType HeightResizePolicy
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.HEIGHT_RESIZE_POLICY).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "HeightResizePolicy get error!");
                }
                switch (temp)
                {
                    case "FIXED":
                    return ResizePolicyType.Fixed;
                    case "USE_NATURAL_SIZE":
                    return ResizePolicyType.UseNaturalSize;
                    case "FILL_TO_PARENT":
                    return ResizePolicyType.FillToParent;
                    case "SIZE_RELATIVE_TO_PARENT":
                    return ResizePolicyType.SizeRelativeToParent;
                    case "SIZE_FIXED_OFFSET_FROM_PARENT":
                    return ResizePolicyType.SizeFixedOffsetFromParent;
                    case "FIT_TO_CHILDREN":
                    return ResizePolicyType.FitToChildren;
                    case "DIMENSION_DEPENDENCY":
                    return ResizePolicyType.DimensionDependency;
                    case "USE_ASSIGNED_SIZE":
                    return ResizePolicyType.UseAssignedSize;
                    default:
                    return ResizePolicyType.Fixed;
                }
            }
            set
            {
                SetProperty(Actor.Property.HEIGHT_RESIZE_POLICY, new Tizen.NUI.PropertyValue((int)value));
            }
        }

        /// <summary>
        /// Gets/Sets the policy to use when setting size with size negotiation. 
        /// Defaults to  SizeScalePolicyType.UseSizeSet.
        /// </summary>
        public SizeScalePolicyType SizeScalePolicy
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.SIZE_SCALE_POLICY).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "SizeScalePolicy get error!");
                }
                switch (temp)
                {
                    case "USE_SIZE_SET":
                    return SizeScalePolicyType.UseSizeSet;
                    case "FIT_WITH_ASPECT_RATIO":
                    return SizeScalePolicyType.FitWithAspectRatio;
                    case "FILL_WITH_ASPECT_RATIO":
                    return SizeScalePolicyType.FillWithAspectRatio;
                    default:
                    return SizeScalePolicyType.UseSizeSet;
                }
            }
            set
            {
                string valueToString = "";
                switch (value)
                {
                    case SizeScalePolicyType.UseSizeSet:
                    {
                        valueToString = "USE_SIZE_SET";
                        break;
                    }
                    case SizeScalePolicyType.FitWithAspectRatio:
                    {
                        valueToString = "FIT_WITH_ASPECT_RATIO";
                        break;
                    }
                    case SizeScalePolicyType.FillWithAspectRatio:
                    {
                        valueToString = "FILL_WITH_ASPECT_RATIO";
                        break;
                    }
                    default:
                    {
                        valueToString = "USE_SIZE_SET";
                        break;
                    }
                }
                SetProperty(Actor.Property.SIZE_SCALE_POLICY, new Tizen.NUI.PropertyValue(valueToString));
            }
        }

        /// <summary>
        ///  Gets/Sets the status of whether the width size is dependent on height size.
        /// </summary>
        public bool WidthDependentOnHeight
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.WIDTH_FOR_HEIGHT).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.WIDTH_FOR_HEIGHT, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        ///  Gets/Sets the status of whether the height size is dependent on width size.
        /// </summary>
        public bool HeightDependentOnWidth
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.HEIGHT_FOR_WIDTH).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.HEIGHT_FOR_WIDTH, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets the padding for use in layout.
        /// </summary>
        public Vector4 Padding
        {
            get
            {
                Vector4 temp = new Vector4(0.0f, 0.0f, 0.0f, 0.0f);
                GetProperty(Actor.Property.PADDING).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.PADDING, new Tizen.NUI.PropertyValue(value));
            }
        }


        /// <summary>
        /// Gets/Sets the minimum size an actor can be assigned in size negotiation.
        /// </summary>
        public Size2D MinimumSize
        {
            get
            {
                Size2D temp = new Size2D(0, 0);
                GetProperty(Actor.Property.MINIMUM_SIZE).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.MINIMUM_SIZE, new Tizen.NUI.PropertyValue(value));
            }
        }


        /// <summary>
        /// Gets/Sets the maximum size an actor can be assigned in size negotiation.
        /// </summary>
        public Size2D MaximumSize
        {
            get
            {
                Size2D temp = new Size2D(0, 0);
                GetProperty(Actor.Property.MAXIMUM_SIZE).Get(temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.MAXIMUM_SIZE, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets whether a child actor inherits it's parent's position.
        /// Default is to inherit. 
        /// Switching this off means that using Position sets the actor's world position, i.e. translates from the world origin(0,0,0) to the anchor point of the actor.
        /// </summary>
        public bool InheritPosition
        {
            get
            {
                bool temp = false;
                GetProperty(Actor.Property.INHERIT_POSITION).Get(ref temp);
                return temp;
            }
            set
            {
                SetProperty(Actor.Property.INHERIT_POSITION, new Tizen.NUI.PropertyValue(value));
            }
        }

        /// <summary>
        /// Gets/Sets clipping behavior(mode) of it's children 
        /// </summary>
        public ClippingModeType ClippingMode
        {
            get
            {
                string temp;
                if (GetProperty(Actor.Property.CLIPPING_MODE).Get(out temp) == false)
                {
                    //Tizen.Log.Error("NUI", "ClippingMode get error!");
                }
                switch (temp)
                {
                    case "DISABLED":
                    return ClippingModeType.Disabled;
                    case "CLIP_CHILDREN":
                    return ClippingModeType.ClipChildren;
                    default:
                    return ClippingModeType.Disabled;
                }
            }
            set
            {
                SetProperty(Actor.Property.CLIPPING_MODE, new Tizen.NUI.PropertyValue((int)value));
            }
        }

    }

    /// <summary>
    /// This specifies whether the Actor uses its own color, or inherits
    /// ColorMode.UseOwnColor : Actor will use its own color
    /// ColorMode.UseParentColor : Actor will use its parent color
    /// ColorMode.UseOwnMultiplyParentColor : Actor will blend its color with its parents color.
    /// ColorMode.UseOwnMultiplyParentAlpha : Actor will blend its alpha with its parents alpha. This means when parent fades in or out child does as well. This is the default.
    /// </summary>
    public enum ColorMode
    {
        UseOwnColor,
        UseParentColor,
        UseOwnMultiplyParentColor,
        UseOwnMultiplyParentAlpha
    }

    /// <summary>
    /// This specifies the dimesion of width or heigh for size negotiation.
    /// </summary>
    public enum DimensionType
    {
        Width = 0x1,
        Height = 0x2,
        AllDimensions = 0x3
    }

    /// <summary>
    /// This specifies draw mode types
    /// </summary>
    public enum DrawModeType
    {
        Normal = 0,
        Overlay2D = 1,
        Stencil = 3
    }

    /// <summary>
    /// This specifies resize policy types
    /// </summary>
    public enum ResizePolicyType
    {
        Fixed,
        UseNaturalSize,
        FillToParent,
        SizeRelativeToParent,
        SizeFixedOffsetFromParent,
        FitToChildren,
        DimensionDependency,
        UseAssignedSize
    }

    /// <summary>
    /// This specifies size scale policy types
    /// </summary>
    public enum SizeScalePolicyType
    {
        UseSizeSet,
        FitWithAspectRatio,
        FillWithAspectRatio
    }

    /// <summary>
    /// This specifies clipping mode types
    /// </summary>
    public enum ClippingModeType
    {
        Disabled,
        ClipChildren
    }

}
