// Copyright (c) 2017 Samsung Electronics Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// This File has been auto-generated by SWIG and then modified using DALi Ruby Scripts
// Some have been manually changed


namespace Tizen.NUI
{

    using System;
    using System.Runtime.InteropServices;
    using Tizen.NUI.BaseComponents;

    /// <summary>
    /// Provides the functionality of handling keyboard navigation and maintaining the two dimensional keyboard focus chain.<br>
    /// It provides functionality of setting the focus and moving the focus in four directions(i.e.Left, Right, Up and Down).<br>
    /// It also draws a highlight for the focused View and sends a event when the focus is changed.<br>
    /// </summary>
    public class FocusManager : BaseHandle
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        private CustomAlgorithmInterfaceWrapper _customAlgorithmInterfaceWrapper;

        internal FocusManager(global::System.IntPtr cPtr, bool cMemoryOwn) : base(NDalicManualPINVOKE.FocusManager_SWIGUpcast(cPtr), cMemoryOwn)
        {
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(FocusManager obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        /// <summary>
        /// To make FocusManager instance be disposed.
        /// </summary>
        protected override void Dispose(DisposeTypes type)
        {
            if(disposed)
            {
                return;
            }

            if(type == DisposeTypes.Explicit)
            {
                //Called by User
                //Release your own managed resources here.
                //You should release all of your own disposable objects here.
            }

            //Release your own unmanaged resources here.
            //You should not access any managed member here except static instance.
            //because the execution order of Finalizes is non-deterministic.

            if (swigCPtr.Handle != global::System.IntPtr.Zero)
            {
                if (swigCMemOwn)
                {
                    swigCMemOwn = false;
                    NDalicManualPINVOKE.delete_FocusManager(swigCPtr);
                }
                swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
            }

            base.Dispose(type);
        }


        ///<summary>
        ///Event arguments that passed via PreFocusChange signal
        /// </summary>
        public class PreFocusChangeEventArgs : EventArgs
        {
            private View _current;
            private View _proposed;
            private View.FocusDirection _direction;

            public View CurrentView
            {
                get
                {
                    return _current;
                }
                set
                {
                    _current = value;
                }
            }

            public View ProposedView
            {
                get
                {
                    return _proposed;
                }
                set
                {
                    _proposed = value;
                }
            }

            public View.FocusDirection Direction
            {
                get
                {
                    return _direction;
                }
                set
                {
                    _direction = value;
                }
            }
        }

        private EventHandlerWithReturnType<object, PreFocusChangeEventArgs, View> _preFocusChangeEventHandler;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        internal delegate IntPtr PreFocusChangeEventCallback(IntPtr current, IntPtr proposed, View.FocusDirection direction);
        private PreFocusChangeEventCallback _preFocusChangeCallback;

        /// <summary>
        /// PreFocusChange will be triggered before the focus is going to be changed.<br>
        /// FocusManager makes the best guess for which view to focus towards the given direction, but applications might want to change that.<br>
        /// By connecting with this event, they can check the proposed view to focus and return a different view if they wish.<br>
        /// This event is only triggered when the navigation key is pressed and KeyboardFocusManager tries to move the focus automatically.<br>
        /// It won't be emitted for focus movement by calling SetCurrentFocusView directly.<br>
        /// </summary>
        public event EventHandlerWithReturnType<object, PreFocusChangeEventArgs, View> PreFocusChange
        {
            add
            {
                if (_preFocusChangeEventHandler == null)
                {
#if DEBUG_ON
                    Tizen.Log.Debug("NUI", "con1) PreFocusChangeSignal().Empty = " + PreFocusChangeSignal().Empty());
                    Tizen.Log.Debug("NUI", "con2) PreFocusChangeSignal().GetConnectionCount = " + PreFocusChangeSignal().GetConnectionCount());
#endif
                    _preFocusChangeCallback = OnPreFocusChange;
                    PreFocusChangeSignal().Connect(_preFocusChangeCallback);
#if DEBUG_ON
                    Tizen.Log.Debug("NUI", "con3) PreFocusChangeSignal().Empty = " + PreFocusChangeSignal().Empty());
                    Tizen.Log.Debug("NUI", "con4) PreFocusChangeSignal().GetConnectionCount = " + PreFocusChangeSignal().GetConnectionCount());
#endif
                }
                _preFocusChangeEventHandler += value;
            }
            remove
            {
                _preFocusChangeEventHandler -= value;
                if (_preFocusChangeEventHandler == null && PreFocusChangeSignal().Empty() == false)
                {
#if DEBUG_ON
                    Tizen.Log.Debug("NUI", "discon1) PreFocusChangeSignal().Empty = " + PreFocusChangeSignal().Empty());
                    Tizen.Log.Debug("NUI", "discon2) PreFocusChangeSignal().GetConnectionCount = " + PreFocusChangeSignal().GetConnectionCount());
#endif
                    PreFocusChangeSignal().Disconnect(_preFocusChangeCallback);
#if DEBUG_ON
                    Tizen.Log.Debug("NUI", "discon3) PreFocusChangeSignal().Empty = " + PreFocusChangeSignal().Empty());
                    Tizen.Log.Debug("NUI", "discon4) PreFocusChangeSignal().GetConnectionCount = " + PreFocusChangeSignal().GetConnectionCount());
#endif
                }
            }
        }

        private IntPtr OnPreFocusChange(IntPtr current, IntPtr proposed, View.FocusDirection direction)
        {
            View view = null;
            PreFocusChangeEventArgs e = new PreFocusChangeEventArgs();

            if (current != global::System.IntPtr.Zero)
            {
                e.CurrentView = View.GetViewFromPtr(current);
            }
            if (proposed != global::System.IntPtr.Zero)
            {
                e.ProposedView = View.GetViewFromPtr(proposed);
            }
            e.Direction = direction;

            if (_preFocusChangeEventHandler != null)
            {
                view = _preFocusChangeEventHandler(this, e);
            }

            if (view)
            {
                return view.GetPtrfromView();
            }
            else
            {
                //if (e.ProposedView) return proposed;
                //else return current;
                return current; //xb.teng
            }
        }

        ///<summary>
        ///Event arguments that passed via FocusChanged signal.
        /// </summary>
        public class FocusChangedEventArgs : EventArgs
        {
            private View _current;
            private View _next;

            public View CurrentView
            {
                get
                {
                    return _current;
                }
                set
                {
                    _current = value;
                }
            }

            public View NextView
            {
                get
                {
                    return _next;
                }
                set
                {
                    _next = value;
                }
            }
        }

        private EventHandler<FocusChangedEventArgs> _focusChangedEventHandler;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        internal delegate void FocusChangedEventCallback(IntPtr current, IntPtr next);
        private FocusChangedEventCallback _focusChangedEventCallback;

        /// <summary>
        /// FocusGroupChanged will be triggered after the current focused view has been changed.
        /// </summary>
        public event EventHandler<FocusChangedEventArgs> FocusChanged
        {
            add
            {
                if (_focusChangedEventCallback == null)
                {
                    _focusChangedEventCallback = OnFocusChanged;
                    FocusChangedSignal().Connect(_focusChangedEventCallback);
                }
                _focusChangedEventHandler += value;
            }
            remove
            {
                _focusChangedEventHandler -= value;

                if (_focusChangedEventCallback == null && FocusChangedSignal().Empty() == false)
                {
                    FocusChangedSignal().Disconnect(_focusChangedEventCallback);
                }
            }
        }

        private void OnFocusChanged(IntPtr current, IntPtr next)
        {
            FocusChangedEventArgs e = new FocusChangedEventArgs();

            e.CurrentView = View.GetViewFromPtr(current);
            e.NextView = View.GetViewFromPtr(next);

            if (_focusChangedEventHandler != null)
            {
                _focusChangedEventHandler(this, e);
            }
        }

        ///<summary>
        ///Event arguments that passed via FocusGroupChanged signal.
        /// </summary>
        public class FocusGroupChangedEventArgs : EventArgs
        {
            private View _current;
            private bool _forwardDirection;

            public View CurrentView
            {
                get
                {
                    return _current;
                }
                set
                {
                    _current = value;
                }
            }

            public bool ForwardDirection
            {
                get
                {
                    return _forwardDirection;
                }
                set
                {
                    _forwardDirection = value;
                }
            }
        }

        private EventHandler<FocusGroupChangedEventArgs> _focusGroupChangedEventHandler;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void FocusGroupChangedEventCallback(IntPtr current, bool forwardDirection);
        private FocusGroupChangedEventCallback _focusGroupChangedEventCallback;

        /// <summary>
        /// FocusGroupChanged will be triggered when the focus group has been changed.<br>
        /// If the current focus group has a parent layout control, FocusManager will make the best guess for the next focus group to move the focus to in the given direction (forward or backward).<br>
        /// If not, the application has to set the new focus.<br>
        /// </summary>
        public event EventHandler<FocusGroupChangedEventArgs> FocusGroupChanged
        {
            add
            {
                if (_focusGroupChangedEventCallback == null)
                {
                    _focusGroupChangedEventCallback = OnFocusGroupChanged;
                    FocusGroupChangedSignal().Connect(_focusGroupChangedEventCallback);
                }
                _focusGroupChangedEventHandler += value;
            }
            remove
            {
                _focusGroupChangedEventHandler -= value;

                if (_focusGroupChangedEventCallback == null && FocusGroupChangedSignal().Empty() == false)
                {
                    FocusGroupChangedSignal().Disconnect(_focusGroupChangedEventCallback);
                }
            }
        }

        private void OnFocusGroupChanged(IntPtr current, bool forwardDirection)
        {
            FocusGroupChangedEventArgs e = new FocusGroupChangedEventArgs();

            e.CurrentView = View.GetViewFromPtr(current);
            e.ForwardDirection = forwardDirection;

            if (_focusGroupChangedEventHandler != null)
            {
                _focusGroupChangedEventHandler(this, e);
            }
        }

        ///<summary>
        ///Event arguments that passed via FocusedViewEnterKey signal
        /// </summary>
        public class FocusedViewActivatedEventArgs : EventArgs
        {
            private View _view;

            public View View
            {
                get
                {
                    return _view;
                }
                set
                {
                    _view = value;
                }
            }
        }

        private EventHandler<FocusedViewActivatedEventArgs> _focusedViewEnterKeyEventHandler;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void FocusedViewEnterKeyEventCallback(IntPtr view);
        private FocusedViewEnterKeyEventCallback _focusedViewEnterKeyEventCallback;

        /// <summary>
        /// FocusedViewActivated will be triggered when the current focused view has the enter key pressed on it.
        /// </summary>
        public event EventHandler<FocusedViewActivatedEventArgs> FocusedViewActivated
        {
            add
            {
                if (_focusedViewEnterKeyEventCallback == null)
                {
                    _focusedViewEnterKeyEventCallback = OnFocusedViewEnterKey;
                    FocusedViewEnterKeySignal().Connect(_focusedViewEnterKeyEventCallback);
                }
                _focusedViewEnterKeyEventHandler += value;
            }
            remove
            {
                _focusedViewEnterKeyEventHandler -= value;

                if (_focusedViewEnterKeyEventCallback == null && FocusedViewEnterKeySignal().Empty() == false)
                {
                    FocusedViewEnterKeySignal().Disconnect(_focusedViewEnterKeyEventCallback);
                }
            }
        }

        private void OnFocusedViewEnterKey(IntPtr view)
        {
            FocusedViewActivatedEventArgs e = new FocusedViewActivatedEventArgs();

            e.View = View.GetViewFromPtr(view);

            if (_focusedViewEnterKeyEventHandler != null)
            {
                _focusedViewEnterKeyEventHandler(this, e);
            }
        }


        internal FocusManager() : this(NDalicManualPINVOKE.new_FocusManager(), true)
        {
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal static FocusManager Get()
        {
            FocusManager ret = new FocusManager(NDalicManualPINVOKE.FocusManager_Get(), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Moves the keyboard focus to the given View.<br>
        /// Only one View can be focused at the same time.<br>
        /// The View must be in the stage already and keyboard focusable.<br>
        /// </summary>
        /// <param name="view">The View to be focused</param>
        /// <returns>Whether the focus is successful or not</returns>
        public bool SetCurrentFocusView(View view)
        {
            bool ret = NDalicManualPINVOKE.FocusManager_SetCurrentFocusActor(swigCPtr, View.getCPtr(view));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Gets the current focused view.
        /// </summary>
        /// <returns>A handle to the current focused View or an empty handle if no View is focused</returns>
        public View GetCurrentFocusView()
        {
            View ret = new View(NDalicManualPINVOKE.FocusManager_GetCurrentFocusActor(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            if (ret.HasBody() == false)
            {
                return null;
            }
            return ret;
        }

        /// <summary>
        /// Moves the focus to the next focusable View in the focus chain in the given direction(according to the focus traversal order).
        /// </summary>
        /// <param name="direction">The direction of focus movement</param>
        /// <returns>true if the movement was successful</returns>
        public bool MoveFocus(View.FocusDirection direction)
        {
            bool ret = NDalicManualPINVOKE.FocusManager_MoveFocus(swigCPtr, (int)direction);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Clears the focus from the current focused view if any, so that no view is focused in the focus chain.<br>
        /// It will emit FocusChanged event without current focused View.<br>
        /// </summary>
        public void ClearFocus()
        {
            NDalicManualPINVOKE.FocusManager_ClearFocus(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Move the focus to prev focused view.
        /// </summary>
        public void MoveFocusBackward()
        {
            NDalicManualPINVOKE.FocusManager_MoveFocusBackward(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Sets/Gets the status of whether the focus movement should be looped within the same focus group.<br>
        /// The focus movement is not looped by default.<br>
        /// </summary>
        public bool FocusGroupLoop
        {
            set
            {
                SetFocusGroupLoop(value);
            }
            get
            {
                return GetFocusGroupLoop();
            }
        }

        internal void SetFocusGroupLoop(bool enabled)
        {
            NDalicManualPINVOKE.FocusManager_SetFocusGroupLoop(swigCPtr, enabled);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal bool GetFocusGroupLoop()
        {
            bool ret = NDalicManualPINVOKE.FocusManager_GetFocusGroupLoop(swigCPtr);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Sets whether an View is a focus group that can limit the scope of focus movement to its child views in the focus chain.<br>
        /// Layout controls set themselves as focus groups by default.<br>
        /// </summary>
        /// <param name="view">The View to be set as a focus group</param>
        /// <param name="isFocusGroup">Whether to set the View as a focus group or not</param>
        public void SetAsFocusGroup(View view, bool isFocusGroup)
        {
            NDalicManualPINVOKE.FocusManager_SetAsFocusGroup(swigCPtr, View.getCPtr(view), isFocusGroup);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        /// <summary>
        /// Checks whether the view is set as a focus group or not.
        /// </summary>
        /// <param name="view">The View to be checked</param>
        /// <returns>Whether the View is set as a focus group</returns>
        public bool IsFocusGroup(View view)
        {
            bool ret = NDalicManualPINVOKE.FocusManager_IsFocusGroup(swigCPtr, View.getCPtr(view));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// <summary>
        /// Returns the closest ancestor of the given view that is a focus group.
        /// </summary>
        /// <param name="view">The View to be checked for its focus group</param>
        /// <returns>The focus group the given view belongs to or an empty handle if the given view</returns>
        public View GetFocusGroup(View view)
        {
            View ret = new View(NDalicManualPINVOKE.FocusManager_GetFocusGroup(swigCPtr, View.getCPtr(view)), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            if (ret.HasBody() == false)
            {
                return null;
            }
            return ret;
        }

        /// <summary>
        /// Sets/Gets the focus indicator View.<br>
        /// This will replace the default focus indicator view in FocusManager and will be added to the focused view as a highlight.<br>
        /// </summary>
        public View FocusIndicator
        {
            set
            {
                SetFocusIndicatorView(value);
            }
            get
            {
                return GetFocusIndicatorView();
            }
        }

        internal void SetFocusIndicatorView(View indicator)
        {
            NDalicManualPINVOKE.FocusManager_SetFocusIndicatorActor(swigCPtr, View.getCPtr(indicator));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal View GetFocusIndicatorView()
        {
            View ret = new View(NDalicManualPINVOKE.FocusManager_GetFocusIndicatorActor(swigCPtr), true);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            if (ret.HasBody() == false)
            {
                return null;
            }
            return ret;
        }

        /// <summary>
        /// Provide the implementation of custom Focus algorithm interface to allow the app define the focus logic.<br>
        /// </summary>
        /// <param name="arg0">The user's implementation of ICustomFocusAlgorithm</param>
        public void SetCustomAlgorithm(ICustomFocusAlgorithm arg0)
        {
            _customAlgorithmInterfaceWrapper = new CustomAlgorithmInterfaceWrapper();
            _customAlgorithmInterfaceWrapper.SetFocusAlgorithm(arg0);

            NDalicPINVOKE.SetCustomAlgorithm(swigCPtr, CustomAlgorithmInterface.getCPtr(_customAlgorithmInterfaceWrapper));
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
        }

        internal PreFocusChangeSignal PreFocusChangeSignal()
        {
            PreFocusChangeSignal ret = new PreFocusChangeSignal(NDalicManualPINVOKE.FocusManager_PreFocusChangeSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal FocusChangedSignal FocusChangedSignal()
        {
            FocusChangedSignal ret = new FocusChangedSignal(NDalicManualPINVOKE.FocusManager_FocusChangedSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal FocusGroupChangedSignal FocusGroupChangedSignal()
        {
            FocusGroupChangedSignal ret = new FocusGroupChangedSignal(NDalicManualPINVOKE.FocusManager_FocusGroupChangedSignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        internal ViewSignal FocusedViewEnterKeySignal()
        {
            ViewSignal ret = new ViewSignal(NDalicManualPINVOKE.FocusManager_FocusedActorEnterKeySignal(swigCPtr), false);
            if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        private static readonly FocusManager instance = FocusManager.Get();

        /// <summary>
        /// Gets the singleton of FocusManager object.
        /// </summary>
        public static FocusManager Instance
        {
            get
            {
                return instance;
            }
        }

        /// <summary>
        /// ICustomFocusAlgorithm is used to provide custom keyboard focus algorithm for retrieving the next focusable view.<br>
        /// The application can implement the interface and override the keyboard focus behaviour.<br>
        /// If focus is changing within a layout container, then the layout container is queried first to provide the next focusable view.<br>
        /// If this does not provide a valid view, then the Keyboard FocusManager will check focusable properties to determine next focusable actor.<br>
        /// If focusable properties are not set, then the Keyboard FocusManager calls the GetNextFocusableView() method of this interface.<br>
        /// </summary>
        public interface ICustomFocusAlgorithm
        {
            View GetNextFocusableView(View current, View proposed, View.FocusDirection direction);
        }

        private class CustomAlgorithmInterfaceWrapper : CustomAlgorithmInterface
        {
            private FocusManager.ICustomFocusAlgorithm _customFocusAlgorithm;

            public CustomAlgorithmInterfaceWrapper()
            {
            }

            public void SetFocusAlgorithm(FocusManager.ICustomFocusAlgorithm customFocusAlgorithm)
            {
                _customFocusAlgorithm = customFocusAlgorithm;
            }

            public override View GetNextFocusableView(View current, View proposed, View.FocusDirection direction)
            {
                View currentView = View.DownCast<View>(current);
                View proposedView = View.DownCast<View>(proposed);
                return _customFocusAlgorithm.GetNextFocusableView(currentView, proposedView, direction);
            }
        }


        /*********************************************************************************/
        /*** will be removed/deprecated                                                  ***/
        /*********************************************************************************/

        ///<summary>
        ///Event arguments that passed via FocusedViewEnterKey signal
        /// </summary>
        public class FocusedViewEnterKeyEventArgs : EventArgs
        {
            private View _view;

            public View View
            {
                get
                {
                    return _view;
                }
                set
                {
                    _view = value;
                }
            }
        }

        private EventHandler<FocusedViewEnterKeyEventArgs> _focusedViewEnterKeyEventHandler2;
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate void FocusedViewEnterKeyEventCallback2(IntPtr view);
        private FocusedViewEnterKeyEventCallback2 _focusedViewEnterKeyEventCallback2;

        /// <summary>
        /// FocusedViewActivated will be triggered when the current focused view has the enter key pressed on it.
        /// </summary>
        public event EventHandler<FocusedViewEnterKeyEventArgs> FocusedViewEnterKeyPressed
        {
            add
            {
                if (_focusedViewEnterKeyEventCallback2 == null)
                {
                    _focusedViewEnterKeyEventCallback2 = OnFocusedViewEnterKey2;
                    FocusedViewEnterKeySignal().Connect(_focusedViewEnterKeyEventCallback2);
                }
                _focusedViewEnterKeyEventHandler2 += value;
            }
            remove
            {
                _focusedViewEnterKeyEventHandler2 -= value;

                if (_focusedViewEnterKeyEventCallback2 == null && FocusedViewEnterKeySignal().Empty() == false)
                {
                    FocusedViewEnterKeySignal().Disconnect(_focusedViewEnterKeyEventCallback2);
                }
            }
        }

        private void OnFocusedViewEnterKey2(IntPtr view)
        {
            FocusedViewEnterKeyEventArgs e = new FocusedViewEnterKeyEventArgs();

            e.View = View.GetViewFromPtr(view);

            if (_focusedViewEnterKeyEventHandler2 != null)
            {
                _focusedViewEnterKeyEventHandler2(this, e);
            }
        }
        

    }
}
